---
# PostgresqlResearch: один сервер — Postgres (данные на /data), Trino (серверные настройки).
# API для K6 не запускается по умолчанию; запуск вручную.

- name: PG Research server
  hosts: data_server
  become: true
  vars:
    repo_dir: /opt/PostgresqlResearch
    work_dir: "{{ repo_dir }}"
    postgres_host: "127.0.0.1"
    trino_host: "127.0.0.1"

  tasks:
    - name: Stat secret vars file
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/../inventory/group_vars/all_secret.yml"
      register: all_secret_file
      run_once: true
      delegate_to: localhost
      become: false

    - name: Load secret variables from file
      ansible.builtin.include_vars:
        file: "{{ playbook_dir }}/../inventory/group_vars/all_secret.yml"
      when: all_secret_file.stat.exists
      run_once: true
      delegate_to: localhost
      become: false

    - name: Set postgres_password from environment
      ansible.builtin.set_fact:
        postgres_password: "{{ lookup('env', 'POSTGRES_PASSWORD') }}"
      when: postgres_password is not defined or postgres_password | length == 0
      run_once: true
      become: false

    - name: Fail if postgres password not set
      ansible.builtin.fail:
        msg: "Set postgres_password: copy inventory/group_vars/all_secret.example.yml to all_secret.yml and set postgres_password, or export POSTGRES_PASSWORD before running ansible-playbook."
      when: postgres_password is not defined or postgres_password | length == 0
      run_once: true
      become: false

    - name: Install packages
      ansible.builtin.apt:
        update_cache: true
        name: [ca-certificates, curl, git, jq, docker.io]
        state: present

    - name: Create keyring dir for Docker
      ansible.builtin.file:
        path: /etc/apt/keyrings
        state: directory
        mode: "0755"

    - name: Add Docker GPG key
      ansible.builtin.get_url:
        url: https://download.docker.com/linux/ubuntu/gpg
        dest: /etc/apt/keyrings/docker.asc
        mode: "0644"
        force: true

    - name: Add Docker repository
      ansible.builtin.apt_repository:
        repo: "deb [arch={{ ansible_architecture | replace('x86_64','amd64') }} signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        filename: docker
        state: present
      notify: Update apt cache

    - name: Install docker-compose-plugin
      ansible.builtin.apt:
        update_cache: true
        name: docker-compose-plugin
        state: present

    - name: Find second (data) block device
      ansible.builtin.shell: |
        lsblk -rnd -o NAME,TYPE | awk '$2=="disk" {print "/dev/"$1}' | sed -n '2p'
      register: data_dev_out
      changed_when: false

    - name: Prepare data disk and mount /data
      block:
        - name: Check if data device has a filesystem
          ansible.builtin.command: blkid -o value -s TYPE {{ data_dev_out.stdout }}
          register: blkid_data
          changed_when: false
          failed_when: false
          when: data_dev_out.stdout | length > 0

        - name: Create ext4 on data device if unformatted
          ansible.builtin.filesystem:
            fstype: ext4
            dev: "{{ data_dev_out.stdout }}"
          when: data_dev_out.stdout | length > 0 and blkid_data.rc != 0

        - name: Get UUID of data device
          ansible.builtin.shell: "blkid -s UUID -o value {{ data_dev_out.stdout }}"
          register: data_uuid
          changed_when: false
          when: data_dev_out.stdout | length > 0

        - name: Create /data and add fstab
          ansible.builtin.mount:
            path: /data
            src: "UUID={{ data_uuid.stdout }}"
            fstype: ext4
            state: mounted
            opts: defaults,nofail
          when: data_dev_out.stdout | length > 0 and data_uuid.stdout | length > 0

        - name: Ensure /data exists (no extra disk)
          ansible.builtin.file:
            path: /data
            state: directory
            mode: "0755"
          when: data_dev_out.stdout | length == 0

        - name: Create /data/postgres
          ansible.builtin.file:
            path: "{{ data_mount }}/postgres"
            state: directory
            owner: "70"
            group: "70"
            mode: "0700"

        - name: Ensure postgres data dir ownership (recursive)
          ansible.builtin.command:
            cmd: chown -R 70:70 "{{ data_mount }}/postgres"

    - name: Enable and start Docker
      ansible.builtin.systemd:
        name: docker
        state: started
        enabled: true

    - name: Clone or update repo
      ansible.builtin.git:
        repo: "{{ repo_url }}"
        dest: "{{ repo_dir }}"
        version: "{{ repo_ref }}"
        depth: 1
        force: true
        update: true

    - name: Write docker-compose override
      ansible.builtin.template:
        src: docker-compose-override.yml.j2
        dest: "{{ work_dir }}/compose/docker-compose.override.yml"

    # На сервере данные Postgres всегда на отдельном диске /data (не из репо)
    - name: Set postgres data volume to data disk in base compose
      ansible.builtin.lineinfile:
        path: "{{ work_dir }}/compose/docker-compose.yml"
        regexp: '^\s+-\s+.*:/var/lib/postgresql'
        line: "      - {{ data_mount }}/postgres:/var/lib/postgresql"

    - name: Write Trino jvm.config
      ansible.builtin.template:
        src: trino-jvm.config.j2
        dest: "{{ work_dir }}/compose/trino/jvm.config"

    - name: Write Trino config.properties
      ansible.builtin.template:
        src: trino-config.properties.j2
        dest: "{{ work_dir }}/compose/trino/config.properties"

    - name: Write Trino catalog postgres.properties
      ansible.builtin.template:
        src: trino-catalog-postgres.properties.j2
        dest: "{{ work_dir }}/compose/trino/catalog/postgres.properties"

    - name: Ensure .env on server
      ansible.builtin.template:
        src: env.server.j2
        dest: "{{ work_dir }}/.env"
        mode: "0600"

    - name: Start Docker Compose (postgres, trino)
      ansible.builtin.command:
        cmd: docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml up -d postgres trino
        chdir: "{{ work_dir }}"

    - name: Wait for Postgres (with diagnostics on failure)
      block:
        - name: Wait for Postgres
          ansible.builtin.shell: |
            docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml exec -T postgres pg_isready -U postgres
          args:
            chdir: "{{ work_dir }}"
          register: wait_pg
          until: wait_pg.rc == 0
          retries: 15
          delay: 2
      rescue:
        - name: Diagnose — docker compose ps -a
          ansible.builtin.command:
            cmd: docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml ps -a
            chdir: "{{ work_dir }}"
          register: diag_ps
          ignore_errors: true

        - name: Diagnose — postgres container logs
          ansible.builtin.command:
            cmd: docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml logs --tail=150 postgres
            chdir: "{{ work_dir }}"
          register: diag_logs
          ignore_errors: true

        - name: Show Postgres failure diagnostics
          ansible.builtin.debug:
            msg:
              - "========== Postgres container is not running =========="
              - "--- docker compose ps -a ---"
              - "{{ (diag_ps.stdout_lines or diag_ps.stderr_lines) | default(['(no output)']) }}"
              - "--- postgres logs (last 150 lines) ---"
              - "{{ (diag_logs.stdout_lines or diag_logs.stderr_lines) | default(['(no output)']) }}"

        - name: Fail with hint
          ansible.builtin.fail:
            msg: "Postgres did not become ready. Check the 'Show Postgres failure diagnostics' output above for docker compose ps -a and postgres logs."

    # Уже инициализированная БД игнорирует POSTGRES_PASSWORD — один раз выставляем пароль (подключение со старым postgres)
    - name: Set ALTER USER SQL for password sync
      ansible.builtin.set_fact:
        pg_alter_sql: "ALTER USER postgres PASSWORD '{{ postgres_password | replace(\"'\", \"''\") }}';"

    - name: Write ALTER USER SQL to temp file
      ansible.builtin.copy:
        content: "{{ pg_alter_sql }}"
        dest: /tmp/pg_alter_password.sql
        mode: "0600"

    - name: Sync postgres user password (for existing DB)
      ansible.builtin.shell: |
        cat /tmp/pg_alter_password.sql | docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml exec -T postgres env PGPASSWORD=postgres psql -U postgres
      args:
        chdir: "{{ work_dir }}"
      register: pg_password_sync
      ignore_errors: true

    - name: Write password to temp file for verify
      ansible.builtin.copy:
        content: "{{ postgres_password }}"
        dest: /tmp/pg_password_verify.txt
        mode: "0600"
      when: pg_password_sync.rc != 0

    - name: Verify postgres accepts new password (when Sync skipped — DB already has new password)
      ansible.builtin.shell: |
        export PGPASSWORD="$(cat /tmp/pg_password_verify.txt)" && docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml exec -T postgres psql -U postgres -c "SELECT 1;"
      args:
        chdir: "{{ work_dir }}"
      when: pg_password_sync.rc != 0
      register: pg_verify_new
      ignore_errors: true
      changed_when: false

    - name: Remove temp password file
      ansible.builtin.file:
        path: /tmp/pg_password_verify.txt
        state: absent
      when: pg_password_sync.rc != 0

    - name: Fail if postgres password not in sync
      ansible.builtin.fail:
        msg: "Could not set or verify postgres password. Sync failed and connection with new password failed. Check Sync task error or set password manually in the container."
      when: pg_password_sync.rc != 0 and (pg_verify_new.rc | default(1) != 0)

    - name: Remove temp SQL file
      ansible.builtin.file:
        path: /tmp/pg_alter_password.sql
        state: absent

    - name: Wait for Trino (with diagnostics on failure)
      block:
        - name: Wait for Trino
          ansible.builtin.uri:
            url: http://localhost:8080/v1/info
            status_code: 200
          register: wait_trino
          until: wait_trino.status == 200
          retries: 15
          delay: 2
      rescue:
        - name: Diagnose — docker compose ps -a (Trino)
          ansible.builtin.command:
            cmd: docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml ps -a
            chdir: "{{ work_dir }}"
          register: diag_trino_ps
          ignore_errors: true

        - name: Diagnose — trino container logs
          ansible.builtin.command:
            cmd: docker compose -f compose/docker-compose.yml -f compose/docker-compose.override.yml logs --tail=150 trino
            chdir: "{{ work_dir }}"
          register: diag_trino_logs
          ignore_errors: true

        - name: Show Trino failure diagnostics
          ansible.builtin.debug:
            msg:
              - "========== Trino did not become ready =========="
              - "--- docker compose ps -a ---"
              - "{{ (diag_trino_ps.stdout_lines or diag_trino_ps.stderr_lines) | default(['(no output)']) }}"
              - "--- trino logs (last 150 lines) ---"
              - "{{ (diag_trino_logs.stdout_lines or diag_trino_logs.stderr_lines) | default(['(no output)']) }}"

        - name: Fail with hint (Trino)
          ansible.builtin.fail:
            msg: "Trino did not become ready. Check the 'Show Trino failure diagnostics' output above for docker compose ps -a and trino logs."

    - name: Install Node.js 20 (NodeSource)
      ansible.builtin.shell: |
        curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
        apt-get install -y nodejs
      args:
        creates: /usr/bin/node

    - name: Enable corepack and pnpm
      ansible.builtin.shell: |
        corepack enable
        corepack prepare pnpm@latest --activate
      args:
        creates: /usr/bin/pnpm

    - name: pnpm install
      ansible.builtin.command:
        cmd: pnpm install
        chdir: "{{ work_dir }}"
      environment:
        PG_HOST: "{{ postgres_host }}"
        TRINO_HOST: "{{ trino_host }}"
        PG_PORT: "5432"
        TRINO_PORT: "8080"
        PG_DATABASE: appdb
        TRINO_CATALOG: postgres
        TRINO_SCHEMA: bench
        TRINO_USER: trino

    - name: Run setup:tables
      ansible.builtin.command:
        cmd: pnpm run setup:tables -- --all
        chdir: "{{ work_dir }}"
      environment:
        PG_HOST: "{{ postgres_host }}"
        TRINO_HOST: "{{ trino_host }}"
        PG_PORT: "5432"
        TRINO_PORT: "8080"
        PG_DATABASE: appdb
        TRINO_CATALOG: postgres
        TRINO_SCHEMA: bench
        TRINO_USER: trino

  handlers:
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
